<!DOCTYPE html>
<html lang="en" dir="ltr">
  <head>
    <link rel="stylesheet" href="./css/style.css">
    <meta charset="utf-8">
    <title></title>
  </head>
  <body>
    <h1 id='grid'>Grid</h1>
    <button type="button" id="red"></button>
    <button type="button" id="blue"></button>
    <button type="button" id="green"></button>
    <button type="button" id="start" disabled></button>
    <button type="button" id="start-dijkstra" disabled></button>
    <button type="button" id="reset"></button>
    <script type="text/javascript">
      //----initialize array of nodes for dijkstra
      let nodes = [];
      let strSet = [];
      let nodeIndex = 0;
      //counter for dijkstra animation setTimeout calculation
      let counter = 0;
      //------------------------------------------
      let numberOfGridColumns = 43;
      let numberOfGridRows = 20;
      //----TODO----remove default value after testing
      let redNode = '';
      let greenNode = '';
      //down keeps track of wether or not the mouse is down
      let down = false;
      document.addEventListener('mousedown', function () {down = true;});
      document.addEventListener('mouseup', function() {down=false;});
      //initialize default mouse state
      let currMouseState = 'blue';
      function changeMouseState() {
        currMouseState = '' + this.id;
      }
      //sets the state of a square to the current mouse state
      function setSquareState() {
        //only run code if mousedown or a click has occured (*possible issues with double clicks)
        if (down || event.detail > 0) {
        //if square is green or red enable selector, set mouse state to square's value, reset square's value
          if (this.value === 'red' || this.value === 'green') {
            document.getElementById(this.value).disabled = false;
            currMouseState = this.value;
            this.value = '';
          } else if (currMouseState === 'red' || currMouseState === 'green') {
            document.getElementById(currMouseState).disabled = true;
            this.value = currMouseState;
            currMouseState = 'blue';
          } else if (this.value === 'blue') {
            currMouseState = this.value;
            this.value = '';
          } else {
            this.value = currMouseState;
          }
          if (this.value === 'red') {
            redNode = this.id;
          } else if (this.value === 'green') {
            greenNode = this.id
          }
          if (greenNode !== '' && redNode !== '') {
            document.getElementById('start').disabled = false;
            document.getElementById('start-dijkstra').disabled = false;
          }
        }
      }
      //createGrid takes in a number of rows and a number of colums and creates a grid of buttons num of rows tall and num of columns wide
      function createGrid(row, col) {
        //for each row creates a seperate div
        for (let i = 0; i < row; i++) {
          let currentRow = document.createElement('div');
          let colId = 'row-' + i;
          currentRow.id = colId;
          document.body.appendChild(currentRow);
          //for each column creates a button and places it inside the current row's div adds an id and an onclick EventListener
          for (let j = 0; j < col; j++) {
            let currentCol = document.createElement('button');
            let currentColId = i + '-' + j;
            currentCol.id = currentColId;
            buildDijkstraGraph(currentColId);
            document.getElementById(colId).appendChild(currentCol);
            //*Issue the last square passed does not get set
            currentCol.addEventListener('mouseout', setSquareState);
            currentCol.addEventListener('click', setSquareState);
          }
        }
      }

      //works ok but running dijkstra's again after grid is reset is very slow
      //resets all square values, dijkstra grid, and strSet
      function resetGrid() {
        index = 0;
        for (let i = 0; i < numberOfGridRows; i++) {
          for (let j = 0; j < numberOfGridColumns; j++) {
            updateNodeValue(i, j, '');
            let currentNode = findNodeByName(i+'-'+j);
            currentNode.closestNode = '';
            currentNode.distanceFromStart = Infinity;
          }
        }
        strSet = [];
        document.getElementById('red').disabled = false;
        document.getElementById('green').disabled = false;
        document.getElementById('start').disabled = false;
        document.getElementById('reset').disabled = true;
      }

      //creates object for every node with a name corresponding to the square's id and places it in nodes array
      function buildDijkstraGraph(name) {
        nodes[nodeIndex] = {
          name: name,
          closestNode: '',
          uToV: 1,
          distanceFromStart: Infinity,
        }
        nodeIndex++;
      }

      //takes in a node name and returns the node it belongs to
      function findNodeByName(name) {
        let nodeToCheck = name.split('-');
        let nodeRow = parseInt(nodeToCheck[0]);
        let nodeCol = parseInt(nodeToCheck[1]);
        let nodeId = (nodeRow*numberOfGridColumns) + nodeCol;
        return nodes[nodeId];
      }

      //takes in a node(object) and returns an array containing all adjacent nodes
      //----TODO----Possibly add functionality to check diagonal adjacent nodes as well
      function updateAdjacentNodes(node) {

        let nodeToCheck = node.name.split('-');
        let nodeRow = parseInt(nodeToCheck[0]);
        let nodeCol = parseInt(nodeToCheck[1]);
        let adjacentNodeRow;
        let adjacentNodeCol;
        let adjacentNodeId;
        let adjacentNodes = [];
        for (let i = 0; i < 4; i++) {
          if (i === 0) {
            adjacentNodeRow = (nodeRow-1);
            adjacentNodeCol = (nodeCol);
          } else if (i === 1) {
            adjacentNodeRow = (nodeRow);
            adjacentNodeCol = (nodeCol+1);
          } else if (i === 2) {
            adjacentNodeRow = (nodeRow+1);
            adjacentNodeCol = (nodeCol);
          } else if (i === 3) {
            adjacentNodeRow = (nodeRow);
            adjacentNodeCol = (nodeCol-1);
          }
          if (adjacentNodeRow > numberOfGridRows-1 || adjacentNodeRow < 0 || adjacentNodeCol > numberOfGridColumns-1 || adjacentNodeCol < 0) {
            continue;
          }
          adjacentNodeId = adjacentNodeRow*numberOfGridColumns + adjacentNodeCol;


          let squareValue = document.getElementById(adjacentNodeRow + '-' + adjacentNodeCol).value;
          if (squareValue !== 'red' & squareValue !== 'blue') {
            //update adjacent nodes distanceFromStart and closestNode if the new distanceFromStart is less than the current distanceFromStart
            let distanceToCheck = node.distanceFromStart + nodes[adjacentNodeId].uToV;
            if (nodes[adjacentNodeId].distanceFromStart > distanceToCheck) {
              nodes[adjacentNodeId].distanceFromStart = distanceToCheck;
              nodes[adjacentNodeId].closestNode = node.name;
            }
            if (nodes[adjacentNodeId].name === greenNode) {
              setTimeout(getShortestPath, counter*10, nodes[adjacentNodeId]);
              return true;
            }

            //*Bug for some reason setTimeout excludes all ids ending in 39 ex: n-39 and doesnt update the value
            //*also for some reason when greenNode is on the right side program stops 2 nodes before if its on left it stops at the greenNode
            //instead of passing an anonymous function passing a named function as parameters fixed both issues
            setTimeout(updateNodeValue, counter*10, adjacentNodeRow, adjacentNodeCol, 'orange')
            //adjacentNodes.push(nodes[adjacentNodeId]);
            counter++;
          }
        }
        return false;
      }

      function updateNodeValue(nodeRow, nodeCol, value) {
        document.getElementById(nodeRow + '-' + nodeCol).value = value;
      }

      function getShortestPath(node) {
        let currentNode = node;
        let shortestPath = [];
        while(currentNode !== redNode) {
          shortestPath.push(currentNode);
          document.getElementById(currentNode.closestNode).value = 'yellow';
          currentNode = findNodeByName(currentNode.closestNode);
        }
      }


      function dijkstra() {
        let startNode = findNodeByName(redNode);
        startNode.distanceFromStart = 0;


        //let adjacentNodes = getAdjacentNodes(nodes[300]);
        while (strSet.length < nodes.length) {

          let lowestDistance = Infinity;
          let u;
          for (let i = 0; i < nodes.length; i++) {
            if (nodes[i].distanceFromStart < lowestDistance && !strSet.includes(nodes[i])) {
              lowestDistance = nodes[i].distanceFromStart;
              u = nodes[i];
            }
          }
          strSet.push(u);

          //find better way of checking if green node was found
          //currently doesn't add green node to strSet
          let isEnd = updateAdjacentNodes(u);
          if (isEnd) {
            document.getElementById('reset').disabled = false;
            break;
          }

        }
      }

      //test function to find the green squre
      //*issues
      //breaks if no green, doesn't show process, start is manually defined instead of startNode
      createGrid(numberOfGridRows, numberOfGridColumns);
      function findGreen() {
        document.getElementById('start').disabled = true;
        let lastNodesVisited = [redNode];
        let isGreen = false;
        while(!isGreen) {
          start:
          for (let j = 0; j < lastNodesVisited.length; j++) {
            let currentNode = lastNodesVisited[j];
            for (let i = 0; i < 4; i++) {
              let nodeToCheck = currentNode.split('-');
              let nodeRow = parseInt(nodeToCheck[0]);
              let nodeCol = parseInt(nodeToCheck[1]);
              let nodeNow = '';
              if (i === 0) {
                nodeNow = document.getElementById((nodeRow-1) + '-' + nodeCol);
              } else if (i === 1) {
                nodeNow = document.getElementById(nodeRow + '-' + (nodeCol+1));
              } else if (i === 2) {
                nodeNow = document.getElementById((nodeRow+1) + '-' + nodeCol);
              } else if (i === 3) {
                nodeNow = document.getElementById(nodeRow + '-' + (nodeCol-1));
              }
              //Important if node does not exist skip
              if (nodeNow === null) {
                continue;
              }
              if (nodeNow.value === 'green') {
                isGreen = true;
                break start;
              } else if (nodeNow.value !== 'blue' && nodeNow.value !== 'red' && nodeNow.value !== 'orange') {
                nodeNow.value = 'orange';
                lastNodesVisited.push(nodeNow.id);
              }
            }
          }
        }
      }

    document.getElementById('red').addEventListener('click', changeMouseState);
    document.getElementById('blue').addEventListener('click', changeMouseState);
    document.getElementById('green').addEventListener('click', changeMouseState);
    document.getElementById('start').addEventListener('click', findGreen);
    document.getElementById('start-dijkstra').addEventListener('click', dijkstra);
    document.getElementById('reset').addEventListener('click', resetGrid);
    //if click occurs change all squares the cursor passes until mouseup
    </script>
  </body>
</html>
